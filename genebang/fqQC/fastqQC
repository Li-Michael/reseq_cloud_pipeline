#!/usr/bin/env python
# -*- coding: UTF-8 -*-
import sys
from optparse import OptionParser
import time
import os
from utils import monitor_controlC,getfileoutprefix
from bootstrap_stat import bootstrap_stat
#from make_fqQC_help import make_fqQC_help
import mhtml_v4 as mhtml
class qc_opt(object):
	def __init__(self):
		self.runfastqc = 0
		self.runstat = 0
		self.fastqc = "fastqc -t 4 %s"
		self.outdir = "."
		self.outprefix = "fqQC"
		self.fileoutprefix = ""
		self.seqlen = 100
		self.qual = 64
		self.indir = "."
def sampleinfo_parse(sampleinfo):
	f = file(sampleinfo,"r")
	ret = []
	for line in f:
		if line.startswith("#"):continue
		sn,files = line.strip().split("\t")[0:2]
		files = files.rstrip(",").split(",")
		ret.append([sn,files])
	f.close()
	return ret
def run_fastqc(opt,sampleinfo):
	snfiles = sampleinfo_parse(sampleinfo)
	for i in xrange(len(snfiles)):
		sn,files = snfiles[i]
		for k in xrange(len(files)):
			files[k] = opt.indir+"/"+files[k]
		cmd = opt.fastqc%(" ".join(files))
		f = file(sn+".fastqc.sh","w")
		f.write(cmd+"\n")
		f.close()
	return 0
def parse_fastqc(sn,f):
	other_infos = []
	info = [sn,]
	tmpfile = f.rsplit(".fq",1)[0]+"_fastqc/fastqc_data.txt"
	if not os.path.isfile(tmpfile):
		tmpfile = f.rsplit(".fastq",1)[0]+"_fastqc/fastqc_data.txt"
	if not os.path.isfile(tmpfile):
		sys.stderr.write("[Error] can not file the fastqc file: %s\n"%tmpfile)
		exit(1)
	fqc = file(tmpfile,"r")
	content = fqc.read().rstrip().split(">>END_MODULE")
	fqc.close()
	for c in content:
		cs = c.strip("\n").split(">>")
		for css in cs:
			#####
			if css.startswith("Basic Statistics"):
				lines = css.split("\n")
				for line in lines:
					if line.startswith("#"):continue
					if line.startswith("Filename"):
						info.append(line.rstrip().split("\t")[1])#filename
					if line.startswith("Encoding"):info.append(line.rstrip().split("\t")[1])#encode
					if line.startswith("Total Sequences"):info.append(line.rstrip().split("\t")[1])#total reads
					if line.startswith("Sequence length"):info.append(line.rstrip().split("\t")[1])#readlen
					if line.startswith("%GC"):info.append(line.rstrip().split("\t")[1])#%GC
			if css.startswith("Overrepresented sequences"):
				lines = css.split("\n")
				if len(lines) <=2:continue
				else:
					for line in lines[1:]:
						if line.startswith("#"):continue
						other_infos.append([sn,f]+line.split("\t"))
	return info,other_infos

cm_content = """####1. 原始序列数据：
高通量测序（如Illumina HiSeq 2000/Miseq等测序平台）测序得到的原始图像文件经碱基识别（Base Calling）分析转化为测序序列（Sequenced Reads），结果以FASTQ文件格式保存，其中既包含了测序序列信息，又包含了各碱基对应的测序质量信息。
测序样本中真实数据随机截取结果如下：
<pre>   @HISEQ:366:H8RBJADXX:2:1101:1383:2233 1:N:0:CATTTT</pre>
<pre>   TAACGGTTGGACGATAGTAAAAAGTCATAGCAAAACCTGTAGCTACTTGTACTAAAAAACAAGTAAGTGTGATCCCCCCTAAACAATAAAATATGTTGAC</pre>
<pre>   +</pre>
<pre>   B@CFFFFFHHHFFFHIIHJJIIIGHIIIHIJJIJIIJJJJJJJIIGIJJHHJIJIJIJIHGHHADDFBCBDCDEEEDDDDDCDDDDDDDDDEDEECDDCD</pre>
<pre>   @HISEQ:366:H8RBJADXX:2:1101:1402:2233 1:N:0:CATTTT</pre>
<pre>   TCCAGTTTACCCACTACTGTACCCGCGTGAATATGATCTCCACCAGACATACGTAATGCTTTAGCTAGTACACGAAAATGCATACCATGATTTTTCTGTC</pre>
<pre>   +</pre>
<pre>   ==8DBB?DH?DFDGGIEIII@D:EBGH@DDFG>BBBF9DD3BFEH;B;FGGG@F;(;CA=CEE:A?E>CDED>?=A@/5;@CCA@9A@A@CDECCCCCC@</pre>

质量与错误率换算公式：
<pre>     <img src="fqQC_help/errorQuality.png" width="120" height="30"/></pre>
详见：Cock, P.J.A., et al. (2009) The Sanger FASTQ file format for sequences with quality scores, and the Solexa/Illumina FASTQ variants, Nucleic Acids Research, 38, 1767-1771.
<br />
####2. 测序数据质量评估
###2.1 测序质量及碱基分布
测序错误率与碱基质量有关，受仪本身、试剂样品等多个因素共同影响。通常序列（Reads）5’端前几个碱基的错误率相对较高,随着序列的延伸，3’端碱基错误率会不断升高，这是由通量测序的技术特点决定。
此外，对于RNA-seq来说，因随机性打断及G/C，和 A/T含量分别相等的原则，理论上GC及AT含量在每个测序循环上应分别相等，且整过程稳定不变呈水平线。对于miR-seq来说，一般小RNA长度均小于测序长度，我们统计时只截取一部分，且受高丰度部分小RNA影响，GC含量并无上述规律，一般波动较为剧烈。
<img src="fqQC_help/seq-quality.png" width="700" height="300" />
左图：横坐标为reads的碱基位置，纵坐标为单碱基质量。
右图：横坐标：测序reads碱基位置; 纵坐标：单碱基所占比例
<br />
###2.2 测序质量汇总
样本测序产出数据质量评估表：
<img src="fqQC_help/seq-quality-table.png" />
Reads：由测序得到的原始图像数据经base calling转化而来的原始序列reads。
ReadLength：测序reads长度，总测序量 = Reads * ReadLength
GC：G+C的数量占总的碱基数目的比例
Q20：测序base质量>20 的比例，即错误率 < 1%（Q20：表示测序错误率为1%）
Q30：测序base质量>30 的比例，即错误率 < 0.1%（Q30：表示测序错误率为0.1%）
"""

def make_result_html(opt,sampleinfo):
	"""
	file sample infomation 
	##GSMorFileName	SampleDetailInformation	SampleNameInProgram	category(int)	category_name(string)
	"""
	html_main = mhtml.simple_main(title="数据质量控制")
	html_main.add_head("数据质量控制")
	html_main.add_enter()
	html_main.add_content_retract("""请先阅读：<a href="HELP/Data_quality_help.html">帮助文档HELP</a>""")
	html_main.add_enter()
	html_main.add_head("1. 样本信息",2)
	html_main.add_content_retract("样本信息列表，包含样本信息及分组信息")
	table ,samplenames,files = mhtml.get_sampleinfo(sampleinfo)
	html_main.add_content_retract(table)
	html_main.add_enter()
	html_main.add_head("2. 测序质量评估",2)
	html_main.add_head("2.1 样本测序质量汇总表",3)
	html_main.add_content(mhtml.xls2table(opt.outdir+"/fqQC.stat.xls")[0])
	note = """Note:
	Reads：由测序得到的原始图像数据经base calling转化而来的原始序列reads。
	ReadLength：测序reads长度，总测序量 = Reads * ReadLength
	GC：G+C的数量占总的碱基数目的比例
	Q20：测序base质量>20 的比例，即错误率 < 1%（Q20：表示测序错误率为1%）
	Q30：测序base质量>30 的比例，即错误率 < 0.1%（Q30：表示测序错误率为0.1%）
	"""
	html_main.add_precontent(note)
	html_main.add_line()
	html_main.add_enter()

	html_main.add_head("2.2 样本测序质量及碱基分布",3)
	html_main.add_content_retract(">>>项目结果: 各样本测序质量结果。")
	html_main.add_content_retract(">>>注: _1, _2 分别代表某一样本双端测序结果。")
	html_main.add_enter()
	for i in xrange(len(samplenames)):
		s = samplenames[i]
		fs = files[i]
		html_main.add_content_retract("""<div id="%s"><strong>%s</strong><small><a href="#%s_x">返回</a></small></div>"""%(s,s+"测序质量",s))
		for f in fs:
			html_main.add_content_retract(f+":")
			html_main.add_content_retract("""<img src="%s/%s.%s.png" width="700" height="300" />"""%(opt.outdir,s,f.split("/")[-1]))
		html_main.add_enter()
	f = file("Data_quality_result.html","w")
	html_main.add_enter()
	f.write(str(html_main)+"\n")
	f.close()
	return 0


def make_help(opt,comment=None):
	if comment == None:
		sys.stderr.write("[INFO] HTML not create!\n")
		return 1
	c = comment.split("\n")
	html_main = mhtml.simple_main(title="数据质量控制 帮助文档",css="../dist")
	html_main.add_head("数据质量控制 帮助文档")
	html_main.add_enter()
	html_main.add_back1()
	html_main.add_enter()
	for line in c:
		if line.startswith("####"):
			html_main.add_head(line[4:],2)
			html_main.add_line()
			html_main.add_enter()
		elif line.startswith("###"):
			html_main.add_head(line[3:],3)
			html_main.add_enter()
		elif line.startswith("##"):
			html_main.add_head(line[2:],4)
			html_main.add_enter()
		else:
			html_main.add_content(line)
	f = file("Data_quality_help.html","w")
	f.write(str(html_main))
	f.close()
	return 0

def run_stat(opt,sampleinfo):
	fout  = file(opt.fileoutprefix+".stat.xls","w")
	fout.write("##Summary of sequencing quality result\n")
	fout.write("#SN\tFileName\tQualityCoding\tReads\tReadLength\tBases(G)\tGC(%)\tQ20(%)\tQ30(%)\tLowQ(<5)\tNs(%)\n")
	fwarn = file(opt.fileoutprefix+".warn.txt","w")
	snfiles = sampleinfo_parse(sampleinfo)
	for i in xrange(len(snfiles)):
		sn,files = snfiles[i]
		num_ends = len(files)
		#figzise = (num_ends*4,2*4)
		for fn in files:
			fn = opt.indir + "/" + fn
			info,other_infos = parse_fastqc(sn,fn)
			strings = bootstrap_stat(sn,fn,opt.seqlen,opt.outdir,opt.qual,times=100000)
			try:
				addbasex = float(info[3])*float(info[4])/1000000000 #add 0830
				addbasex = '%.3f'%addbasex
			except:
				addbasex = "NAN"
			info.insert(5,addbasex) #add 0830
			fout.write("\t".join(info)+"\t"+strings)
			for other_info in other_infos:
				fwarn.write("\t".join(other_info)+"\n")
	fout.close()
	fwarn.close()
	#!!!!!!!!!!!!!!!!!!!!!make_help(opt,comment=cm_content)
	make_result_html(opt,sampleinfo)###  "Data_quality_result_index.html"
	#to do help
	#make_fqQC_help()
	return 0

def __main():
	start_time = time.time()
	ret = 1
	usage = "usage: %prog [options] sampleinfo.txt"
	description = "Contact: Rong Zhengqin <rongzhengqin@aicbio.com>"
	parser = OptionParser(usage,version="%prog 0.1",description = description)

	parser.add_option('--run-fastqc',dest='runfastqc',help='run fastqc',action='store_true')
	parser.add_option('--run-stat',dest='runstat',help='do stat for qc',action='store_true')
	parser.add_option('--qual',dest='qual',help='33 or 64 quality format[64]',metavar='INT',type='int',default=64)
	parser.add_option('--seqlen',dest='seqlen',help='read length[100]',metavar='INT',type='int',default=100)
	parser.add_option('--indir',dest='indir',help='raw data file path',metavar='DIR',type='string',default='.')
	parser.add_option('--outdir',dest='outdir',help='outdir',metavar='DIR',type='string',default='fqQC')
	parser.add_option('--outprefix',dest='outprefix',help='Output file prefix,default=fqQC',metavar='STR',type='string',default='fqQC')
	#parser.add_option('-XXX',dest='XXXX',help="XXXX",metavar='FILE/INT/DIR/XXX',type='string/float/int/XXXX',default=None)
	#parser.add_option('-X',dest='XXXX',help='XXXX',action='store_true')
	##"string", "int", "long", "choice", "float" and "complex"
	##type="choice",choices=["A","B","R","N","C","P"],default="N"

	(options, args) = parser.parse_args()
	if len(args)   != 1:
		parser.print_help()
		return 999
	opt = qc_opt()
	if not (options.runfastqc or options.runstat):
		parser.error("Please use the '--run-fastqc' or '--run-stat' option.")
		return 1
	else:
		opt.runfastqc = options.runfastqc
		opt.runstat   = options.runstat
	opt.indir = options.indir
	opt.seqlen = int(options.seqlen)
	opt.outdir = options.outdir
	opt.outprefix = options.outprefix
	opt.fileoutprefix = getfileoutprefix(opt.outdir,opt.outprefix)
	opt.qual = int(options.qual)
	sys.stderr.write("================ Task Start ================\n")
	if opt.runfastqc:
		ret = run_fastqc(opt,args[0])
	elif opt.runstat:
		ret = run_stat(opt,args[0])
	if ret == 0:
		cost_time = time.time()-start_time
		sys.stderr.write("Time consumed: %.3f\n"%cost_time)
	return ret

if __name__ == "__main__":
	monitor_controlC()
	ret = __main()
	if 0 == ret:
		sys.stderr.write("Task Done.\n")
		exit(0)
	elif 999 == ret:
		sys.stderr.write("[Error] incorrect number of arguments\n")
		exit(1)
	else:
		sys.stderr.write("Task interrupt: Error!\n")
		exit(1)

